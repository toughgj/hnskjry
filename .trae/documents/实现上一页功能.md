# 实现上一页功能

## 需求分析
1. 在悬浮窗中显示上一页按钮的状态
2. 添加测试上一页的按钮
3. 实现上一页的点击逻辑
4. 与现有功能兼容
5. 提供清晰的反馈信息

## 实现方案

### 1. UI设计
- 在悬浮窗的信息栏中添加上一页按钮状态显示
- 添加"测试上一页"按钮，与"测试下一页"按钮并排
- 按钮样式与现有按钮保持一致
- 显示上一页按钮的状态（已找到/未找到）

### 2. 功能实现
- 添加检测上一页按钮的逻辑
- 实现testPrevPageBtn函数，用于测试上一页功能
- 绑定按钮点击事件
- 提供清晰的反馈信息
- 确保与现有功能兼容

### 3. 与现有脚本的集成
- 在createFloatingWindow函数中添加上一页状态显示和测试按钮
- 在bindFloatingWindowEvents函数中绑定事件
- 确保不影响原有功能

## 实现步骤

1. **修改createFloatingWindow函数**：
   - 添加检测上一页按钮的逻辑
   - 在悬浮窗的信息栏中添加上一页状态显示
   - 添加"测试上一页"按钮
   - 与"测试下一页"按钮并排显示

2. **修改bindFloatingWindowEvents函数**：
   - 为"测试上一页"按钮绑定点击事件
   - 调用testPrevPageBtn函数

3. **添加testPrevPageBtn函数**：
   - 查找上一页按钮
   - 点击上一页按钮
   - 提供清晰的反馈信息
   - 处理异常情况
   - 关闭当前悬浮窗
   - 重置全局变量，重新初始化脚本

4. **优化代码结构**：
   - 确保代码逻辑清晰，易于维护
   - 添加适当的日志输出
   - 确保不影响原有功能

## 预期效果
- 悬浮窗中显示上一页按钮状态
- 提供"测试上一页"按钮
- 点击按钮可以手动测试上一页功能
- 与现有功能兼容
- 提供清晰的反馈信息

## 实现代码结构
```javascript
/**
 * 创建左上角漂浮窗口
 */
function createFloatingWindow() {
    // 检测上一页和下一页按钮
    const hasPrevPage = !!document.querySelector('.prev.ng-binding');
    const hasNextPage = !!document.querySelector('.next.ng-binding');
    
    // 原有代码...
    
    // 添加上一页状态和测试按钮
    floatingWindow.innerHTML += `
        <div style="font-size: 12px; color: #666; border-top: 1px solid #eee; padding-top: 10px;">
            <div>上一页按钮：<span style="color: ${hasPrevPage ? '#4CAF50' : '#f44336'}; font-weight: bold;">${hasPrevPage ? '已找到' : '未找到'}</span></div>
            <div>下一页按钮：<span style="color: ${hasNextPage ? '#4CAF50' : '#f44336'}; font-weight: bold;">${hasNextPage ? '已找到' : '未找到'}</span></div>
            <div style="margin-top: 5px; display: flex; align-items: center;">
                <button id="test-prev-btn" style="background: #2196F3; color: white; border: none; border-radius: 4px; padding: 3px 8px; cursor: pointer; font-size: 11px; margin-right: 10px;">测试上一页</button>
                <button id="test-next-btn" style="background: #2196F3; color: white; border: none; border-radius: 4px; padding: 3px 8px; cursor: pointer; font-size: 11px; margin-right: 10px;">测试下一页</button>
                <span>提示：当前页面课程完成后${hasNextPage ? '将自动翻页' : '无下一页'}</span>
            </div>
        </div>
    `;
    
    // 原有代码...
}

/**
 * 绑定漂浮窗口事件
 */
function bindFloatingWindowEvents() {
    // 原有代码...
    
    // 测试上一页按钮
    document.getElementById('test-prev-btn').addEventListener('click', () => {
        testPrevPageBtn();
    });
    
    // 原有代码...
}

/**
 * 测试上一页按钮
 */
function testPrevPageBtn() {
    // 查找上一页按钮
    const prevPageBtn = document.querySelector('.prev.ng-binding');
    if (!prevPageBtn) {
        alert('未找到上一页按钮，无法测试');
        return;
    }
    
    // 点击上一页按钮
    prevPageBtn.click();
    
    // 关闭当前漂浮窗口
    if (floatingWindow) {
        clearInterval(countdownTimer);
        floatingWindow.remove();
        floatingWindow = null;
    }
    
    // 重置全局变量，重新初始化脚本
    setTimeout(() => {
        // 重置全局变量
        courseQueue = [];
        selectedCourses = [];
        currentCourse = null;
        currentWindow = null;
        checkTimer = null;
        startTime = 0;
        messageReceived = false;
        lastProcessTime = 0;
        isConsoleOverridden = false;
        isMessageListenerAdded = false;
        countdown = 10;
        isPaused = false;
        
        // 重新初始化
        setupListPage();
    }, config.pageLoadDelay);
}
```